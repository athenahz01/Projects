<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Le sapin de No√´l d'Athena & Kehan</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #030205;
            font-family: 'Cinzel', serif; user-select: none;
        }
        
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@300;700&family=Great+Vibes&display=swap');

        #intro-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #020205; z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1.5s ease-in-out;
        }
        
        #intro-text-container {
            text-align: center;
            margin-bottom: 40px;
        }

        .intro-line {
            font-family: 'Georgia', serif;
            font-size: 38px; 
            color: #F3E5AB;
            text-shadow: 0 0 10px rgba(224, 192, 151, 0.3);
            margin: 8px 0;
            opacity: 0;
            transform: translateY(15px);
            transition: opacity 1.5s ease, transform 1.5s ease;
            white-space: nowrap;
        }
        
        .intro-line.special {
            font-family: 'Great Vibes', cursive;
            font-size: 42px;
            color: #FFD700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
        }

        .intro-line.visible {
            opacity: 1;
            transform: translateY(0);
        }

        #unwrap-btn {
            opacity: 0;
            padding: 15px 40px;
            background: transparent;
            border: 1px solid #FFD700;
            color: #FFD700;
            font-family: 'Cinzel', serif;
            font-size: 14px;
            letter-spacing: 4px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.8s;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.1);
            pointer-events: none;
        }
        
        #unwrap-btn.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #unwrap-btn:hover {
            background: rgba(255, 215, 0, 0.1);
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.4);
            transform: scale(1.05);
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; align-items: center;
            opacity: 0;
            transition: opacity 2s ease-in;
        }
        #ui-layer.visible { opacity: 1; }

        .header h1 {
            margin-top: 5vh; font-family: 'Pinyon Script', cursive; font-weight: 400; 
            letter-spacing: 1px; color: #E0C097; 
            font-size: 36px; text-shadow: 0 0 20px rgba(224, 192, 151, 0.4);
            padding-bottom: 10px;
        }
        
        .audio-controls {
            position: absolute; top: 40px; right: 40px; pointer-events: auto;
            display: flex; gap: 10px;
        }

        .audio-btn {
            color: #E6E6FA; border: 1px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.5); padding: 0; border-radius: 50%;
            width: 40px; height: 40px; display: flex; justify-content: center; align-items: center;
            cursor: pointer; transition: all 0.3s; font-size: 16px;
        }
        .audio-btn:hover { background: rgba(147, 112, 219, 0.3); box-shadow: 0 0 15px #9370DB; }

        .status-pill {
            position: absolute; 
            bottom: 160px; 
            right: 40px;
            padding: 8px 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50px; color: #fff; font-size: 11px;
            letter-spacing: 3px; background: rgba(20, 10, 30, 0.8);
            backdrop-filter: blur(10px); text-transform: uppercase;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.2);
            transition: all 0.5s ease;
            pointer-events: auto;
        }

        .controls-panel {
            position: absolute; bottom: 30px; left: 40px; width: 200px;
            background: transparent; pointer-events: auto; 
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        
        .control-item {
            display: flex; align-items: center; margin-bottom: 12px;
            color: rgba(230, 230, 250, 0.7); font-family: 'Lato', sans-serif; font-size: 11px; letter-spacing: 1px;
        }
        .icon { width: 24px; color: #B19CD9; font-size: 14px; text-align: center; text-shadow: 0 0 10px #9370DB; }
        b { color: #fff; font-weight: 700; margin-right: 6px; }

        .btn-upload {
            width: 100%; margin-top: 10px; 
            background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(186, 85, 211, 0.3); color: #E6E6FA;
            padding: 12px; cursor: pointer; border-radius: 4px;
            font-size: 10px; letter-spacing: 3px; text-transform: uppercase;
            transition: all 0.4s; font-family: 'Cinzel', serif; font-weight: 700;
            backdrop-filter: blur(4px);
        }
        .btn-upload:hover { 
            background: rgba(138, 43, 226, 0.2);
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.3); border-color: #FFF; 
        }

        #cam-container {
            position: absolute; bottom: 40px; right: 40px; width: 140px; height: 105px;
            border-radius: 8px; overflow: hidden; border: 2px solid rgba(255, 255, 255, 0.2);
            opacity: 0; transition: opacity 0.8s;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #cam-preview { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.8; }
        
        #file-input { display: none; }

        #config-error {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(139, 0, 0, 0.9);
            color: #fff;
            padding: 30px 50px;
            border-radius: 10px;
            text-align: center;
            z-index: 10000;
            font-family: 'Lato', sans-serif;
        }
        #config-error h2 { margin: 0 0 15px 0; color: #FFD700; }
        #config-error code { 
            background: rgba(0,0,0,0.3); 
            padding: 2px 8px; 
            border-radius: 4px;
            font-size: 14px;
        }

        /* === NEW: Photo Navigation UI === */
        #photo-nav {
            position: fixed;
            bottom: 50%;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 100;
        }
        #photo-nav.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .nav-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 215, 0, 0.4);
            color: #FFD700;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }
        .nav-btn:hover {
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
            transform: scale(1.1);
        }

        /* Photo counter */
        #photo-counter {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: #E0C097;
            font-family: 'Lato', sans-serif;
            font-size: 14px;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 0.5s;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
            z-index: 100;
        }
        #photo-counter.visible {
            opacity: 1;
        }

        /* Photo caption display */
        #photo-caption {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFF;
            font-family: 'Great Vibes', cursive;
            font-size: 28px;
            opacity: 0;
            transition: opacity 0.5s;
            text-shadow: 0 2px 20px rgba(255, 215, 0, 0.5);
            text-align: center;
            max-width: 80%;
            z-index: 100;
        }
        #photo-caption.visible {
            opacity: 1;
        }

        /* Photo date */
        #photo-date {
            position: fixed;
            bottom: 55px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-family: 'Lato', sans-serif;
            font-size: 11px;
            letter-spacing: 1px;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 100;
        }
        #photo-date.visible {
            opacity: 1;
        }

        /* === NEW: Upload Modal with Caption === */
        #upload-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        #upload-modal.visible {
            display: flex;
        }
        .modal-content {
            background: linear-gradient(135deg, #1a0a2e 0%, #0d0515 100%);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 16px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
        }
        .modal-content h3 {
            color: #FFD700;
            font-family: 'Cinzel', serif;
            margin: 0 0 20px 0;
            font-size: 18px;
            letter-spacing: 2px;
        }
        .modal-preview {
            width: 100%;
            max-height: 200px;
            object-fit: contain;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .modal-input {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            color: #FFF;
            font-family: 'Lato', sans-serif;
            font-size: 14px;
            margin-bottom: 15px;
            box-sizing: border-box;
        }
        .modal-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .modal-btn {
            padding: 12px 30px;
            border-radius: 8px;
            font-family: 'Cinzel', serif;
            font-size: 12px;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .modal-btn.primary {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border: none;
            color: #000;
        }
        .modal-btn.secondary {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #FFF;
        }
        .modal-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
    </style>

    <script src="firebase-config.js"></script>

    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/+esm",
                "firebase/app": "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js",
                "firebase/auth": "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js",
                "firebase/firestore": "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"
            }
        }
    </script>
</head>
<body>

    <div id="config-error">
        <h2>‚ö†Ô∏è Firebase Not Configured</h2>
        <p>Please copy <code>firebase-config.template.js</code> to <code>firebase-config.js</code><br>and add your Firebase credentials.</p>
    </div>

    <div id="intro-layer">
        <div id="intro-text-container"></div>
        <button id="unwrap-btn">Unwrapping Your Christmas Gift KEKE</button>
    </div>

    <!-- Upload Modal -->
    <div id="upload-modal">
        <div class="modal-content">
            <h3>‚ú® Add a Memory ‚ú®</h3>
            <img id="modal-preview" class="modal-preview" src="" alt="Preview">
            <input type="text" id="caption-input" class="modal-input" placeholder="Add a caption... (optional)" maxlength="100">
            <div class="modal-buttons">
                <button class="modal-btn secondary" id="cancel-upload">Cancel</button>
                <button class="modal-btn primary" id="confirm-upload">Add to Tree</button>
            </div>
        </div>
    </div>

    <div id="ui-layer">
        <div class="header">
            <h1>Le sapin de No√´l d'Athena & Kehan</h1>
        </div>
        
        <div class="audio-controls">
            <div id="prev-btn" class="audio-btn">‚èÆ</div>
            <div id="sound-btn" class="audio-btn">üîá</div>
            <div id="next-btn" class="audio-btn">‚è≠</div>
        </div>

        <div id="status-pill" class="status-pill">Tree Form</div>

        <!-- Photo Navigation (visible in ZOOM mode) -->
        <div id="photo-nav">
            <button class="nav-btn" id="prev-photo">‚ùÆ</button>
            <button class="nav-btn" id="next-photo">‚ùØ</button>
        </div>
        <div id="photo-counter"></div>
        <div id="photo-caption"></div>
        <div id="photo-date"></div>

        <div class="controls-panel">
            <div class="control-item"><span class="icon" style="color:#FFD700">‚óè</span> <b>FIST</b> &nbsp;Gather Tree</div>
            <div class="control-item"><span class="icon" style="color:#B19CD9">‚óã</span> <b>OPEN</b> &nbsp;Starfall</div>
            <div class="control-item"><span class="icon" style="color:#89CFF0">‚óé</span> <b>PINCH</b> &nbsp;View Memory</div>
            
            <button class="btn-upload" onclick="document.getElementById('file-input').click()">Add Memory</button>
            <input type="file" id="file-input" multiple accept="image/*">
        </div>
        
        <div id="cam-container"><video id="cam-preview" autoplay playsinline muted></video></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';
        import { initializeApp } from 'firebase/app';
        import { getAuth, signInAnonymously, signInWithCustomToken } from 'firebase/auth';
        import { getFirestore, collection, addDoc, onSnapshot, orderBy, query } from 'firebase/firestore';

        function checkFirebaseConfig() {
            if (typeof window.__firebase_config === 'undefined') {
                document.getElementById('config-error').style.display = 'block';
                document.getElementById('intro-layer').style.display = 'none';
                return false;
            }
            try {
                const config = JSON.parse(window.__firebase_config);
                if (config.apiKey === "YOUR_API_KEY_HERE" || config.apiKey.includes("PASTE_YOUR")) {
                    document.getElementById('config-error').style.display = 'block';
                    document.getElementById('intro-layer').style.display = 'none';
                    return false;
                }
            } catch (e) {
                document.getElementById('config-error').style.display = 'block';
                document.getElementById('intro-layer').style.display = 'none';
                return false;
            }
            return true;
        }

        if (!checkFirebaseConfig()) {
            throw new Error("Firebase not configured");
        }

        const introLines = [
            "Hiii Kehan",
            "This is a gift made by Athena",
            "for u",
            "and for us",
            "Merry Xmas",
            "Joyeux No√´l",
            "Âú£ËØûÂø´‰πê"
        ];

        async function playIntro() {
            const container = document.getElementById('intro-text-container');
            const btn = document.getElementById('unwrap-btn');

            for (let i = 0; i < introLines.length; i++) {
                const div = document.createElement('div');
                div.className = 'intro-line';
                if (introLines[i].includes('Athena') || introLines[i].includes('Kehan')) {
                    div.classList.add('special');
                }
                div.innerText = introLines[i];
                container.appendChild(div);
                void div.offsetWidth;
                div.classList.add('visible');
                await new Promise(r => setTimeout(r, 1200));
            }
            
            btn.classList.add('visible');
            btn.addEventListener('click', () => {
                const introLayer = document.getElementById('intro-layer');
                introLayer.style.opacity = 0;
                setTimeout(() => {
                    introLayer.style.display = 'none';
                }, 1500);
                
                document.getElementById('ui-layer').classList.add('visible');
                AudioSys.init();
            });
        }

        playIntro();

        const firebaseConfig = JSON.parse(window.__firebase_config);
        const appId = window.__app_id || 'athena-kehan-tree';
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        const PHOTO_CONFIG = {
            maxVisiblePhotos: 30,
            spiralTurns: 4,
            minScale: 0.35,
            maxScale: 0.75,
            treeRadiusTop: 1.5,
            treeRadiusBottom: 12,
            treeHeightTop: 20,
            treeHeightBottom: -16,
            photoSize: 2.2,
            embedDepth: 0.8,
        };

        const CONFIG = {
            colors: {
                gold: new THREE.Color('#FFD700'),
                red: new THREE.Color('#B22222'),      
                green: new THREE.Color('#0B2610'),    
                silver: new THREE.Color('#C0C0C0'),
                babyBlue: new THREE.Color('#89CFF0'), 
                royalPurple: new THREE.Color('#663399'), 
                deepIndigo: new THREE.Color('#4B0082'),  
                lavender: new THREE.Color('#D8BFD8'),    
                warmWhite: new THREE.Color('#FFF8DC') 
            },
            particleCount: {
                shards: 7500,   
                baubles: 1200,  
                lights: 1500    
            },
            treeHeight: 48,     
            baseRadius: 20      
        };

        const STATE = {
            TREE: 'TREE',
            SCATTER: 'GALAXY',
            ZOOM: 'MEMORY'
        };

        let currentState = STATE.TREE;
        let isHandDetected = false;
        let handPosition = { x: 0, y: 0 };
        let globalPhotoCounter = 0;
        let focusedPhotoIndex = -1;

        let scene, camera, renderer, composer, clock;
        let instancedMeshes = {}; 
        let particlesData = [];   
        let photoParticles = [];  
        let allPhotoData = [];  // Store metadata (caption, date)
        const loadedPhotoIds = new Set();
        let dummy = new THREE.Object3D();
        let dummy2 = new THREE.Object3D(); 
        let centerGlow, snowSystem;
        let photoGroup;
        
        // Sparkle system for transitions
        let sparkleSystem, sparkleData = [];
        
        // Ribbon/string connecting photos
        let ribbonLine;

        // Upload state
        let pendingUpload = null;

        const AudioSys = {
            ctx: null,
            masterGain: null,
            isMuted: true,
            melodyTimer: null,
            noteIndex: 0,
            songIndex: 0,
            
            notes: {
                C4: 261.63, D4: 293.66, E4: 329.63, F4: 349.23, Fs4: 369.99, G4: 392.00, A4: 440.00, B4: 493.88,
                C5: 523.25, D5: 587.33, E5: 659.25, F5: 698.46, G5: 783.99
            },

            playlist: [
                {
                    name: "We Wish You a Merry Christmas",
                    bpm: 140,
                    melody: [
                        {n: 'D4', d: 1}, {n: 'G4', d: 1}, {n: 'G4', d: 0.5}, {n: 'A4', d: 0.5}, {n: 'G4', d: 0.5}, {n: 'Fs4', d: 0.5},
                        {n: 'E4', d: 1}, {n: 'E4', d: 1}, {n: 'E4', d: 1}, 
                        {n: 'A4', d: 1}, {n: 'A4', d: 0.5}, {n: 'B4', d: 0.5}, {n: 'A4', d: 0.5}, {n: 'G4', d: 0.5},
                        {n: 'Fs4', d: 1}, {n: 'D4', d: 1}, {n: 'D4', d: 1}, 
                        {n: 'B4', d: 1}, {n: 'B4', d: 0.5}, {n: 'C5', d: 0.5}, {n: 'B4', d: 0.5}, {n: 'A4', d: 0.5},
                        {n: 'G4', d: 1}, {n: 'E4', d: 1},
                        {n: 'D4', d: 0.5}, {n: 'D4', d: 0.5}, {n: 'E4', d: 1}, {n: 'A4', d: 1}, {n: 'Fs4', d: 1},
                        {n: 'G4', d: 3}
                    ]
                },
                {
                    name: "Santa Tell Me",
                    bpm: 120,
                    melody: [
                        {n: 'G4', d: 0.5}, {n: 'A4', d: 0.5}, {n: 'B4', d: 1.5},
                        {n: 'B4', d: 0.5}, {n: 'A4', d: 0.5}, {n: 'G4', d: 0.5}, {n: 'G4', d: 0.5},
                        {n: 'A4', d: 0.5}, {n: 'G4', d: 0.5}, {n: 'E4', d: 2},
                        {n: 'G4', d: 0.5}, {n: 'A4', d: 0.5}, {n: 'B4', d: 1.5}, 
                        {n: 'B4', d: 0.5}, {n: 'C5', d: 0.5}, {n: 'B4', d: 1.5},
                        {n: 'A4', d: 2} 
                    ]
                },
                {
                    name: "Jingle Bells",
                    bpm: 180,
                    melody: [
                        {n: 'E4', d: 1}, {n: 'E4', d: 1}, {n: 'E4', d: 2},
                        {n: 'E4', d: 1}, {n: 'E4', d: 1}, {n: 'E4', d: 2},
                        {n: 'E4', d: 1}, {n: 'G4', d: 1}, {n: 'C4', d: 1.5}, {n: 'D4', d: 0.5}, {n: 'E4', d: 4}
                    ]
                }
            ],

            init: function() {
                if(this.ctx) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.connect(this.ctx.destination);
                this.masterGain.gain.value = 0; 
                this.playMelody();
                document.getElementById('sound-btn').innerText = "üîä";
                this.isMuted = false;
                this.fadeIn();
            },
            
            toggle: function() {
                if(!this.ctx) { this.init(); return; }
                if(this.isMuted) {
                    this.ctx.resume(); this.fadeIn();
                    document.getElementById('sound-btn').innerText = "üîä";
                    this.isMuted = false;
                } else {
                    this.fadeOut();
                    document.getElementById('sound-btn').innerText = "üîá";
                    this.isMuted = true;
                }
            },

            nextSong: function() {
                this.songIndex = (this.songIndex + 1) % this.playlist.length;
                this.noteIndex = 0;
                if(this.melodyTimer) clearTimeout(this.melodyTimer);
                this.playMelody();
            },

            prevSong: function() {
                this.songIndex = (this.songIndex - 1 + this.playlist.length) % this.playlist.length;
                this.noteIndex = 0;
                if(this.melodyTimer) clearTimeout(this.melodyTimer);
                this.playMelody();
            },
            
            fadeIn: function() {
                this.masterGain.gain.cancelScheduledValues(this.ctx.currentTime);
                this.masterGain.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 2);
            },
            
            fadeOut: function() {
                this.masterGain.gain.cancelScheduledValues(this.ctx.currentTime);
                this.masterGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
            },
            
            playMelody: function() {
                const currentSong = this.playlist[this.songIndex];
                const step = () => {
                    const noteData = currentSong.melody[this.noteIndex];
                    const freq = this.notes[noteData.n];
                    const duration = noteData.d * (60 / currentSong.bpm);
                    if (!this.isMuted) this.playBellSound(freq, duration);
                    this.noteIndex++;
                    if (this.noteIndex >= currentSong.melody.length) {
                        this.noteIndex = 0; 
                        this.songIndex = (this.songIndex + 1) % this.playlist.length;
                    }
                    this.melodyTimer = setTimeout(step, duration * 1000);
                };
                step();
            },

            playBellSound: function(freq, duration) {
                if(!this.ctx || this.isMuted) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, t);
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.3, t + 0.05); 
                gain.gain.exponentialRampToValueAtTime(0.001, t + duration * 1.5); 
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(t);
                osc.stop(t + duration * 2);

                const osc2 = this.ctx.createOscillator();
                const gain2 = this.ctx.createGain();
                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(freq * 2, t); 
                gain2.gain.setValueAtTime(0, t);
                gain2.gain.linearRampToValueAtTime(0.05, t + 0.02);
                gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.5); 
                osc2.connect(gain2);
                gain2.connect(this.masterGain);
                osc2.start(t);
                osc2.stop(t + 1);
            },
            
            playChime: function() {
                if(!this.ctx || this.isMuted) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(880, t);
                osc.frequency.exponentialRampToValueAtTime(440, t + 0.5);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(t);
                osc.stop(t + 0.5);
            },
            
            playWhoosh: function() {
                if(!this.ctx || this.isMuted) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                osc.type = 'sawtooth';
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, t);
                filter.frequency.linearRampToValueAtTime(800, t + 0.5);
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.05, t + 0.1);
                gain.gain.linearRampToValueAtTime(0, t + 1.0);
                osc.start(t);
                osc.stop(t + 1.0);
            }
        };

        function calculateTreePosition(index, totalPhotos) {
            const cfg = PHOTO_CONFIG;
            const count = Math.min(totalPhotos, cfg.maxVisiblePhotos);
            const t = count > 1 ? index / (count - 1) : 0.5;
            const y = cfg.treeHeightTop - t * (cfg.treeHeightTop - cfg.treeHeightBottom);
            const baseRadius = cfg.treeRadiusTop + t * (cfg.treeRadiusBottom - cfg.treeRadiusTop);
            const radius = baseRadius * cfg.embedDepth;
            const spiralAngle = t * Math.PI * 2 * cfg.spiralTurns;
            const offsetAngle = (index % 3) * (Math.PI * 2 / 3);
            const angle = spiralAngle + offsetAngle;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const scale = cfg.minScale + t * (cfg.maxScale - cfg.minScale);
            return { x, y, z, scale, angle };
        }

        function calculateGalaxyPosition(index, totalPhotos) {
            const goldenAngle = Math.PI * (3 - Math.sqrt(5));
            const angle = index * goldenAngle;
            const radiusBase = 8 + Math.sqrt(index) * 8;
            const radius = radiusBase + (index % 3) * 3;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const y = (Math.sin(index * 0.5) * 8) + ((index % 5) - 2) * 2;
            return { x, y, z };
        }

        function rebuildPhotoPositions() {
            const totalPhotos = photoParticles.length;
            photoParticles.forEach((p, index) => {
                const treePos = calculateTreePosition(index, totalPhotos);
                p.treePos.set(treePos.x, treePos.y, treePos.z);
                p.baseScale = treePos.scale;
                const galaxyPos = calculateGalaxyPosition(index, totalPhotos);
                p.scatterPos.set(galaxyPos.x, galaxyPos.y, galaxyPos.z);
            });
            updateRibbon();
        }

        // === NEW: Photo Navigation Functions ===
        function navigatePhoto(direction) {
            if (photoParticles.length === 0) return;
            if (currentState !== STATE.ZOOM) {
                currentState = STATE.ZOOM;
                updateUI(currentState);
            }
            
            focusedPhotoIndex += direction;
            if (focusedPhotoIndex < 0) focusedPhotoIndex = photoParticles.length - 1;
            if (focusedPhotoIndex >= photoParticles.length) focusedPhotoIndex = 0;
            
            updatePhotoInfo();
            triggerSparkles();
            AudioSys.playChime();
        }

        function updatePhotoInfo() {
            const counter = document.getElementById('photo-counter');
            const caption = document.getElementById('photo-caption');
            const dateEl = document.getElementById('photo-date');
            
            if (currentState === STATE.ZOOM && focusedPhotoIndex >= 0 && photoParticles.length > 0) {
                counter.textContent = `${focusedPhotoIndex + 1} of ${photoParticles.length} memories`;
                counter.classList.add('visible');
                
                const photoData = allPhotoData[focusedPhotoIndex];
                if (photoData) {
                    if (photoData.caption) {
                        caption.textContent = photoData.caption;
                        caption.classList.add('visible');
                    } else {
                        caption.classList.remove('visible');
                    }
                    
                    if (photoData.timestamp) {
                        const date = new Date(photoData.timestamp);
                        dateEl.textContent = date.toLocaleDateString('en-US', { 
                            year: 'numeric', month: 'long', day: 'numeric' 
                        });
                        dateEl.classList.add('visible');
                    }
                }
            } else {
                counter.classList.remove('visible');
                caption.classList.remove('visible');
                dateEl.classList.remove('visible');
            }
        }

        // === NEW: Sparkle System ===
        function createSparkleSystem() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            
            for (let i = 0; i < 200; i++) {
                positions.push(0, 0, 0);
                colors.push(1, 0.85, 0); // Gold
                sizes.push(Math.random() * 2 + 1);
                sparkleData.push({
                    velocity: new THREE.Vector3(),
                    life: 0,
                    maxLife: 0
                });
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            sparkleSystem = new THREE.Points(geometry, material);
            scene.add(sparkleSystem);
        }

        function triggerSparkles() {
            const positions = sparkleSystem.geometry.attributes.position.array;
            
            for (let i = 0; i < 50; i++) {
                const idx = Math.floor(Math.random() * sparkleData.length);
                const i3 = idx * 3;
                
                // Start from center
                positions[i3] = (Math.random() - 0.5) * 5;
                positions[i3 + 1] = (Math.random() - 0.5) * 5;
                positions[i3 + 2] = 35;
                
                sparkleData[idx].velocity.set(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                sparkleData[idx].life = 1;
                sparkleData[idx].maxLife = 1 + Math.random();
            }
            
            sparkleSystem.geometry.attributes.position.needsUpdate = true;
        }

        function updateSparkles(delta) {
            const positions = sparkleSystem.geometry.attributes.position.array;
            
            for (let i = 0; i < sparkleData.length; i++) {
                const data = sparkleData[i];
                if (data.life > 0) {
                    const i3 = i * 3;
                    positions[i3] += data.velocity.x * delta * 30;
                    positions[i3 + 1] += data.velocity.y * delta * 30;
                    positions[i3 + 2] += data.velocity.z * delta * 30;
                    
                    data.life -= delta / data.maxLife;
                    
                    if (data.life <= 0) {
                        positions[i3 + 2] = -1000; // Hide
                    }
                }
            }
            
            sparkleSystem.geometry.attributes.position.needsUpdate = true;
        }

        // === NEW: Golden Ribbon connecting photos ===
        function createRibbon() {
            const material = new THREE.LineBasicMaterial({ 
                color: 0xFFD700,
                transparent: true,
                opacity: 0.4
            });
            const geometry = new THREE.BufferGeometry();
            ribbonLine = new THREE.Line(geometry, material);
            scene.add(ribbonLine);
        }

        function updateRibbon() {
            if (!ribbonLine || photoParticles.length < 2) return;
            
            // Sort photos by height for ribbon path
            const sorted = [...photoParticles].sort((a, b) => b.treePos.y - a.treePos.y);
            const points = sorted.map(p => p.treePos.clone());
            
            // Add some curve
            const curve = new THREE.CatmullRomCurve3(points);
            const curvePoints = curve.getPoints(photoParticles.length * 10);
            
            ribbonLine.geometry.dispose();
            ribbonLine.geometry = new THREE.BufferGeometry().setFromPoints(curvePoints);
        }

        async function init() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (e) {
                console.warn("Auth failed:", e);
                try { await signInAnonymously(auth); } catch(e2) {}
            }
            
            if (auth.currentUser) {
                const q = query(collection(db, 'artifacts', appId, 'public', 'data', 'tree_photos'), orderBy('timestamp'));
                onSnapshot(q, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            const data = change.doc.data();
                            if (!loadedPhotoIds.has(change.doc.id)) {
                                loadedPhotoIds.add(change.doc.id);
                                allPhotoData.push({
                                    url: data.url,
                                    caption: data.caption || '',
                                    timestamp: data.timestamp
                                });
                                createPolaroid(data.url, photoParticles.length, data.caption);
                            }
                        }
                    });
                }, (err) => console.error("Firestore Listen Error:", err));
            }

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x040206, 0.012);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 4, 60); 

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.strength = 0.9;
            bloomPass.radius = 0.4;
            bloomPass.threshold = 0.5;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            setupLights();
            createCenterPiece();
            initParticles();
            createSnow();
            createSparkleSystem();
            createRibbon();
            
            photoGroup = new THREE.Group();
            photoGroup.renderOrder = 100;
            scene.add(photoGroup);
            
            window.addEventListener('resize', onResize);
            setupUpload();
            setupNavigation();
            
            document.getElementById('sound-btn').addEventListener('click', () => AudioSys.toggle());
            document.getElementById('next-btn').addEventListener('click', () => AudioSys.nextSong());
            document.getElementById('prev-btn').addEventListener('click', () => AudioSys.prevSong());

            clock = new THREE.Clock();
            initAI();
            animate();
        }

        function setupNavigation() {
            // Button navigation
            document.getElementById('prev-photo').addEventListener('click', () => navigatePhoto(-1));
            document.getElementById('next-photo').addEventListener('click', () => navigatePhoto(1));
            
            // Keyboard navigation
            window.addEventListener('keydown', (e) => {
                if (currentState === STATE.ZOOM) {
                    if (e.key === 'ArrowLeft') navigatePhoto(-1);
                    if (e.key === 'ArrowRight') navigatePhoto(1);
                }
            });
            
            // Touch swipe navigation
            let touchStartX = 0;
            document.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
            });
            document.addEventListener('touchend', (e) => {
                if (currentState !== STATE.ZOOM) return;
                const touchEndX = e.changedTouches[0].clientX;
                const diff = touchStartX - touchEndX;
                if (Math.abs(diff) > 50) {
                    navigatePhoto(diff > 0 ? 1 : -1);
                }
            });
        }

        function setupLights() {
            const ambientLight = new THREE.AmbientLight(0xe6e6fa, 0.15);
            scene.add(ambientLight);
            
            const mainLight = new THREE.PointLight(0xffcc66, 2, 60);
            mainLight.position.set(0, 15, 5);
            scene.add(mainLight);

            const rim1 = new THREE.SpotLight(0x8800ff, 6);
            rim1.position.set(40, 30, 20);
            rim1.lookAt(0, 10, 0);
            scene.add(rim1);

            const rim2 = new THREE.SpotLight(0x89CFF0, 4); 
            rim2.position.set(-40, 10, -20);
            rim2.lookAt(0, 10, 0);
            scene.add(rim2);
        }

        function createCenterPiece() {
            const geo = new THREE.OctahedronGeometry(2.5, 0); 
            const mat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, 
                emissive: CONFIG.colors.gold,
                emissiveIntensity: 3.0,
                roughness: 0.1,
                metalness: 1.0
            });
            centerGlow = new THREE.Mesh(geo, mat);
            centerGlow.position.set(0, 26, 0); 
            scene.add(centerGlow);
        }

        function initParticles() {
            const shardGeo = new THREE.TetrahedronGeometry(0.4, 0); 
            const shardMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.green,
                roughness: 0.6,
                metalness: 0.2,
                flatShading: true
            });
            instancedMeshes.shards = new THREE.InstancedMesh(shardGeo, shardMat, CONFIG.particleCount.shards);

            const baubleGeo = new THREE.SphereGeometry(0.75, 32, 16); 
            const baubleMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, 
                roughness: 0.05, 
                metalness: 0.95,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1
            });
            instancedMeshes.baubles = new THREE.InstancedMesh(baubleGeo, baubleMat, CONFIG.particleCount.baubles);

            const lightGeo = new THREE.SphereGeometry(0.25, 8, 8); 
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); 
            instancedMeshes.lights = new THREE.InstancedMesh(lightGeo, lightMat, CONFIG.particleCount.lights);

            const capGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.25, 8);
            const capMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.gold, roughness: 0.2, metalness: 1.0
            });
            instancedMeshes.baubleCaps = new THREE.InstancedMesh(capGeo, capMat, CONFIG.particleCount.baubles);

            for(let key in instancedMeshes) {
                scene.add(instancedMeshes[key]);
            }
            
            generateLayout(instancedMeshes.shards, 'shards', CONFIG.particleCount.shards);
            generateLayout(instancedMeshes.baubles, 'baubles', CONFIG.particleCount.baubles);
            generateLayout(instancedMeshes.lights, 'lights', CONFIG.particleCount.lights);
        }

        function createSnow() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<2500; i++) {
                pos.push((Math.random()-0.5)*100, (Math.random()-0.5)*80, (Math.random()-0.5)*100);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({
                color: 0xE6E6FA, size: 0.25, transparent: true, opacity: 0.8
            });
            snowSystem = new THREE.Points(geo, mat);
            scene.add(snowSystem);
        }

        function generateLayout(mesh, type, count) {
            const tempColor = new THREE.Color();
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const h = (Math.random() * CONFIG.treeHeight) - (CONFIG.treeHeight/2) + 2; 
                const hNorm = (h + CONFIG.treeHeight/2) / CONFIG.treeHeight; 
                const maxR = CONFIG.baseRadius * (1 - hNorm); 
                let r = maxR * Math.sqrt(Math.random());
                if (type === 'baubles') r = maxR * (0.85 + Math.random() * 0.25); 
                if (type === 'lights') r = maxR * (0.7 + Math.random() * 0.3); 
                const tx = Math.cos(angle) * r;
                const tz = Math.sin(angle) * r;
                const ty = h;

                const arms = 3;
                const spinFactor = 4.0; 
                const galaxyRadius = 60; 
                const gR = Math.pow(Math.random(), 0.5) * galaxyRadius; 
                const armOffset = Math.floor(Math.random() * arms) * (Math.PI * 2 / arms);
                const gAngle = armOffset + (gR * 0.1 * spinFactor);
                const spread = (Math.random() - 0.5) * 5.0 * (1 - gR/galaxyRadius);
                const gx = Math.cos(gAngle) * gR + Math.cos(gAngle + Math.PI/2) * spread;
                const gz = Math.sin(gAngle) * gR + Math.sin(gAngle + Math.PI/2) * spread;
                const gy = (Math.random() - 0.5) * (15 * Math.exp(-gR * 0.05)); 

                if (type === 'baubles') {
                    const rand = Math.random();
                    if (rand > 0.85) tempColor.set(CONFIG.colors.royalPurple);
                    else if (rand > 0.70) tempColor.set(CONFIG.colors.deepIndigo);
                    else if (rand > 0.55) tempColor.set(CONFIG.colors.gold);
                    else if (rand > 0.40) tempColor.set(CONFIG.colors.babyBlue); 
                    else if (rand > 0.30) tempColor.set(CONFIG.colors.lavender); 
                    else if (rand > 0.15) tempColor.set(CONFIG.colors.silver);
                    else tempColor.set(CONFIG.colors.red); 
                    mesh.setColorAt(i, tempColor);
                }
                if (type === 'shards') {
                    if (Math.random() > 0.9) tempColor.set(CONFIG.colors.lavender); 
                    else tempColor.set(CONFIG.colors.green).offsetHSL(0, 0, (Math.random()-0.5)*0.1);
                    mesh.setColorAt(i, tempColor);
                }
                if (type === 'lights') {
                    const rand = Math.random();
                    if (rand > 0.6) tempColor.set(CONFIG.colors.warmWhite);
                    else if (rand > 0.4) tempColor.set(CONFIG.colors.gold);
                    else if (rand > 0.2) tempColor.set(CONFIG.colors.royalPurple); 
                    else tempColor.set(CONFIG.colors.babyBlue); 
                    mesh.setColorAt(i, tempColor);
                }

                particlesData.push({
                    mesh: mesh, index: i, type: type,
                    treePos: new THREE.Vector3(tx, ty, tz),
                    scatterPos: new THREE.Vector3(gx, gy, gz),
                    currentPos: new THREE.Vector3(tx, ty, tz), 
                    speed: 0.5 + Math.random(), phase: Math.random() * 10,
                    baseColor: tempColor.clone(),
                    baseScale: (type === 'shards') ? (0.6 + Math.random()*0.4) : (0.8 + Math.random()*0.5)
                });

                dummy.position.set(tx, ty, tz);
                dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            }
            if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
            mesh.instanceMatrix.needsUpdate = true;
        }

        function resizeImage(base64Str, maxWidth = 512, maxHeight = 512) {
            return new Promise((resolve) => {
                const img = new Image();
                img.src = base64Str;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;
                    if (width > height) {
                        if (width > maxWidth) { height *= maxWidth / width; width = maxWidth; }
                    } else {
                        if (height > maxHeight) { width *= maxHeight / height; height = maxHeight; }
                    }
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    resolve(canvas.toDataURL('image/jpeg', 0.7));
                };
            });
        }

        function createPolaroid(url, index, caption = '') {
            new THREE.TextureLoader().load(url, (tex) => {
                tex.colorSpace = THREE.SRGBColorSpace; 
                const imgWidth = tex.image.width;
                const imgHeight = tex.image.height;
                const aspect = imgWidth / imgHeight;
                
                const cfg = PHOTO_CONFIG;
                let worldW = cfg.photoSize; 
                let worldH = cfg.photoSize / aspect;
                
                const frameGeo = new THREE.PlaneGeometry(worldW + 0.3, worldH + 0.6);
                const frameMat = new THREE.MeshStandardMaterial({ 
                    color: 0xFFF8DC, 
                    roughness: 0.5, 
                    metalness: 0.2,
                    side: THREE.DoubleSide
                });
                const frame = new THREE.Mesh(frameGeo, frameMat);
                
                const imgGeo = new THREE.PlaneGeometry(worldW, worldH);
                const imgMat = new THREE.MeshBasicMaterial({ map: tex });
                const img = new THREE.Mesh(imgGeo, imgMat);
                img.position.z = 0.02; 
                img.position.y = 0.12; 
                frame.add(img);

                const bowGeo = new THREE.SphereGeometry(0.18); 
                const bowMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.royalPurple });
                const bow = new THREE.Mesh(bowGeo, bowMat);
                bow.position.set(0, (worldH/2) + 0.35, 0.1);
                frame.add(bow);

                const treePos = calculateTreePosition(index, photoParticles.length + 1);
                const galaxyPos = calculateGalaxyPosition(index, photoParticles.length + 1);

                frame.position.set(treePos.x, treePos.y, treePos.z);
                frame.lookAt(0, treePos.y, 0); 
                frame.rotation.y += Math.PI;
                
                photoGroup.add(frame);

                photoParticles.push({
                    mesh: frame, 
                    treePos: new THREE.Vector3(treePos.x, treePos.y, treePos.z),
                    treeRot: frame.rotation.clone(), 
                    scatterPos: new THREE.Vector3(galaxyPos.x, galaxyPos.y, galaxyPos.z),
                    scatterRot: new THREE.Euler(Math.random() * 0.2, Math.random() * 0.2, Math.random() * 0.2),
                    baseScale: treePos.scale,
                    index: index,
                    caption: caption
                });

                rebuildPhotoPositions();
            });
        }

        function setupUpload() {
            const fileInput = document.getElementById('file-input');
            const modal = document.getElementById('upload-modal');
            const preview = document.getElementById('modal-preview');
            const captionInput = document.getElementById('caption-input');
            const cancelBtn = document.getElementById('cancel-upload');
            const confirmBtn = document.getElementById('confirm-upload');
            
            fileInput.addEventListener('change', async (e) => {
                if (e.target.files && e.target.files[0]) {
                    const file = e.target.files[0];
                    const reader = new FileReader();
                    reader.onload = async (evt) => {
                        const rawBase64 = evt.target.result;
                        const resizedBase64 = await resizeImage(rawBase64);
                        
                        // Show modal
                        preview.src = resizedBase64;
                        captionInput.value = '';
                        modal.classList.add('visible');
                        pendingUpload = resizedBase64;
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            cancelBtn.addEventListener('click', () => {
                modal.classList.remove('visible');
                pendingUpload = null;
                fileInput.value = '';
            });
            
            confirmBtn.addEventListener('click', async () => {
                if (!pendingUpload) return;
                
                const caption = captionInput.value.trim();
                
                try {
                    await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'tree_photos'), {
                        url: pendingUpload,
                        caption: caption,
                        timestamp: Date.now()
                    });
                    AudioSys.playChime();
                    triggerSparkles();
                } catch(err) {
                    console.error("Upload error", err);
                }
                
                modal.classList.remove('visible');
                pendingUpload = null;
                fileInput.value = '';
            });
        }

        function updateUI(state) {
            const pill = document.getElementById('status-pill');
            const photoNav = document.getElementById('photo-nav');
            
            let t = "", color = "#aaa", border = "rgba(255,255,255,0.1)";
            
            if(state === STATE.TREE) { 
                t = "Tree Form"; 
                photoNav.classList.remove('visible');
            }
            if(state === STATE.SCATTER) { 
                t = "Galaxy Mode"; 
                color = "#9370DB"; 
                border = "rgba(147, 112, 219, 0.5)";
                photoNav.classList.remove('visible');
            }
            if(state === STATE.ZOOM) { 
                t = "Viewing Memory"; 
                color = "#FFF"; 
                border = "#FFF";
                photoNav.classList.add('visible');
            }
            
            pill.innerText = t;
            pill.style.color = color;
            pill.style.borderColor = border;
            
            updatePhotoInfo();
            
            // Update ribbon visibility
            if (ribbonLine) {
                ribbonLine.visible = (state === STATE.TREE);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            if (currentState === STATE.TREE) {
                scene.rotation.y += 0.002; 
                scene.rotation.x *= 0.95; 
                scene.rotation.z *= 0.95;
            } else if (currentState === STATE.SCATTER) {
                if (isHandDetected) {
                    scene.rotation.y += (handPosition.x * 0.5 - scene.rotation.y) * 0.05;
                    scene.rotation.x += (handPosition.y * 0.5 - scene.rotation.x) * 0.05;
                } else {
                    scene.rotation.y += 0.001;
                }
            } else if (currentState === STATE.ZOOM) {
                scene.rotation.y += (0 - scene.rotation.y) * 0.05; 
                scene.rotation.x *= 0.95;
            }

            centerGlow.rotation.y = time * 0.5;
            centerGlow.scale.setScalar(1 + Math.sin(time*2) * 0.1);

            // Update sparkles
            updateSparkles(delta);

            let capCounter = 0;
            particlesData.forEach(p => {
                let target;
                if (currentState === STATE.TREE) {
                    target = p.treePos;
                } else {
                    target = p.scatterPos.clone();
                    target.y += Math.sin(time * 0.5 + p.phase) * 2.0;
                }
                p.currentPos.lerp(target, 0.04);
                dummy.position.copy(p.currentPos);
                if (p.type === 'shards') {
                    dummy.rotation.set(time * 0.2 + p.index, time * 0.1, 0);
                } else {
                    dummy.rotation.set(0, 0, 0);
                }
                let scale = p.baseScale;
                const tempCol = new THREE.Color();
                if (p.type === 'lights') {
                    const blink = Math.sin(time * 3 + p.phase);
                    scale *= (0.8 + 0.4 * blink);
                    if (blink > 0.5) p.mesh.setColorAt(p.index, tempCol.copy(p.baseColor).multiplyScalar(1.5));
                    else p.mesh.setColorAt(p.index, p.baseColor);
                }
                if (currentState === STATE.ZOOM) scale *= 0.3; 
                dummy.scale.setScalar(scale);
                dummy.updateMatrix();
                p.mesh.setMatrixAt(p.index, dummy.matrix);
                if (p.type === 'baubles') {
                    dummy2.position.copy(p.currentPos);
                    dummy2.position.y += 0.45 * scale; 
                    dummy2.rotation.copy(dummy.rotation);
                    dummy2.scale.setScalar(scale);
                    dummy2.updateMatrix();
                    instancedMeshes.baubleCaps.setMatrixAt(capCounter++, dummy2.matrix);
                }
            });
            if (instancedMeshes.lights) instancedMeshes.lights.instanceColor.needsUpdate = true;
            for(let key in instancedMeshes) instancedMeshes[key].instanceMatrix.needsUpdate = true;

            const snowPos = snowSystem.geometry.attributes.position.array;
            for(let i=1; i<snowPos.length; i+=3) {
                snowPos[i] -= 0.1; 
                if (snowPos[i] < -40) snowPos[i] = 40;
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;

            photoParticles.forEach((p, idx) => {
                const isFocused = currentState === STATE.ZOOM && idx === focusedPhotoIndex;
                
                if (isFocused) {
                    p.mesh.visible = true;
                    const tPos = new THREE.Vector3(0, 0, 35);
                    p.mesh.position.lerp(tPos, 0.08);
                    const lookTarget = camera.position.clone();
                    p.mesh.lookAt(lookTarget);
                    p.mesh.scale.lerp(new THREE.Vector3(2.5, 2.5, 2.5), 0.08);
                    p.mesh.rotation.z = 0;
                    
                } else if (currentState === STATE.ZOOM) {
                    p.mesh.visible = true;
                    const tPos = p.scatterPos.clone();
                    tPos.z -= 30;
                    p.mesh.position.lerp(tPos, 0.04);
                    p.mesh.scale.lerp(new THREE.Vector3(0.25, 0.25, 0.25), 0.06);
                    p.mesh.renderOrder = 0;
                    
                } else if (currentState === STATE.TREE) {
                    p.mesh.visible = true;
                    p.mesh.position.lerp(p.treePos, 0.06);
                    const targetScale = p.baseScale;
                    p.mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.06);
                    p.mesh.lookAt(0, p.mesh.position.y, 0);
                    p.mesh.rotation.y += Math.PI;
                    p.mesh.rotation.z = Math.sin(time * 0.5 + idx * 0.3) * 0.02;
                    p.mesh.renderOrder = 0;
                    
                } else {
                    p.mesh.visible = true;
                    const tPos = p.scatterPos.clone();
                    tPos.y += Math.sin(time * 0.3 + idx * 0.5) * 1.5;
                    p.mesh.position.lerp(tPos, 0.04);
                    p.mesh.scale.lerp(new THREE.Vector3(0.6, 0.6, 0.6), 0.06);
                    p.mesh.lookAt(camera.position);
                    p.mesh.renderOrder = 0;
                }
            });
            
            composer.render();
        }

        async function initAI() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
                const handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });
                const video = document.getElementById('cam-preview');
                navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } }).then(stream => {
                    video.srcObject = stream;
                    video.addEventListener('loadeddata', () => {
                        document.getElementById('cam-container').style.opacity = 1;
                        loop(handLandmarker, video);
                    });
                });
            } catch (e) { console.warn("AI Init failed, fallback to keyboard", e); setupMouseFallback(); }
        }

        let lastTime = -1;
        function loop(lm, vid) {
            if (vid.currentTime !== lastTime) {
                lastTime = vid.currentTime;
                const result = lm.detectForVideo(vid, performance.now());
                if (result.landmarks && result.landmarks.length > 0) {
                    isHandDetected = true;
                    const h = result.landmarks[0];
                    handPosition.x = (h[9].x - 0.5) * 2;
                    handPosition.y = (h[9].y - 0.5) * 2;
                    const indexTip = h[8];
                    const thumbTip = h[4];
                    const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                    const isPinching = pinchDist < 0.06;
                    let openCount = 0;
                    if(h[8].y < h[6].y) openCount++; 
                    if(h[12].y < h[10].y) openCount++; 
                    if(h[16].y < h[14].y) openCount++; 
                    if(h[20].y < h[18].y) openCount++; 
                    let nextState = currentState;
                    if (isPinching && currentState === STATE.SCATTER) {
                        nextState = STATE.ZOOM;
                    } else if (openCount >= 4) {
                        nextState = STATE.SCATTER;
                    } else if (openCount <= 1 && !isPinching) {
                        nextState = STATE.TREE; 
                    }
                    if (nextState !== currentState) {
                        currentState = nextState;
                        updateUI(currentState);
                        AudioSys.playWhoosh(); 
                        if (currentState === STATE.ZOOM && photoParticles.length > 0) {
                            focusedPhotoIndex = globalPhotoCounter % photoParticles.length;
                            globalPhotoCounter++;
                            AudioSys.playChime();
                            triggerSparkles();
                        } else {
                            focusedPhotoIndex = -1;
                        }
                    }
                }
            }
            requestAnimationFrame(() => loop(lm, vid));
        }

        function setupMouseFallback() {
            window.addEventListener('keydown', (e) => {
                if(e.key === '1') { currentState = STATE.TREE; focusedPhotoIndex = -1; }
                if(e.key === '2') { currentState = STATE.SCATTER; focusedPhotoIndex = -1; }
                if(e.key === '3') {
                    currentState = STATE.ZOOM;
                    if (photoParticles.length > 0) {
                        focusedPhotoIndex = globalPhotoCounter % photoParticles.length;
                        globalPhotoCounter++;
                        triggerSparkles();
                    }
                }
                updateUI(currentState);
                AudioSys.playWhoosh();
            });
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>